---
layout: post
title: vibe‑coding 九阳神功之规：不要相信任何模型的上下文，tasks.md 才是你唯一的真相
permalink: /jy/gui/
tags: [AI, vibe-coding, 九阳神功]
---
# vibe‑coding 九阳神功之**规**：不要相信任何模型的上下文，tasks.md 才是你唯一的真相

> 系列顺序：[夯（Git）](/jy/git/) → [抄](/jy/chao/) → [学](/jy/xue/) → [喂](/jy/wei/) → **规** → [验](/jy/yan/) → [测](/jy/ce/) → [扩](/jy/kuo/) → [收](/jy/shou/)
> 一句话：**人跟 AI 对决，人唯一的优势就是上下文。把上下文写在文件里，你就永远掌握主动权。**

AI 编程现在最大的坑不是"不会写"，而是：

- 写得太快
- 改得太多
- 炸了没后路
- 炸完你甚至不知道它到底改了哪些文件

所以我准备写一套 **vibe‑coding 九阳神功**：核心不是提示词，而是把 AI 变成"可控交付的队友"。

这套"九阳神功"我先定了九个字诀：

- **夯**：Git 生存技能（刹车 / 保险 / 录像）
- **抄**：拆解 `yfge/orion`、`ai-shifu/ai-shifu` 的优秀骨架，搭底盘
- **学**：学习行业黑话，会组合技术栈、不懂原理也能不翻车
- **喂**：把 API 文档 / 资料结构化成可执行知识
- **规**：让 AI 出计划 + `tasks.md`，按清单推进
- **验**：多模型交叉验证，专治幻觉
- **测**：自动测试，交付有证据
- **扩**：扩展认知边界，但必须可验证
- **收**：上线交付、监控回滚、复盘闭环

这篇咱们讲第五式 **规**：**约束产生质量，自由产生混乱。**

---

## 先说结论：不要相信任何模型的上下文

这是整篇"规"的核心，也是我做了大半年 vibe‑coding 最深的体会：

> **人跟 AI 的对决中，人唯一的优势就是上下文。**

AI 的上下文是什么？是一个对话窗口。你关掉它、刷新它、换个模型、token 超限——上下文就没了。AI 不知道自己上一轮说过什么，不知道你们达成过什么共识，不知道哪些任务做了哪些没做。

而人的上下文呢？如果你只靠脑子记——说实话也好不到哪去。两小时后你也忘了。

**所以，把上下文写在文件里。**

- `tasks.md`：当前做到哪了、下一步做什么
- `design.md`：为什么这么设计、有什么约束
- 每完成一个任务，更新 tasks.md + `git commit`

这样你就拥有了一个**永不丢失的上下文**。你可以随时中止、随时恢复、随时换模型、随时开新对话——因为你的真相不在对话里，在文件里。

---

## 第一步：理清工作项，生成 tasks.md

### 为什么是 tasks.md 而不是 Jira/Notion？

因为 tasks.md 有三个碾压级优势：

1. **AI 能直接读写**：你跟 AI 说"看 tasks.md，继续下一个任务"，它就知道干什么
2. **Git 能追踪**：谁改了什么、什么时候改的、改之前是什么样，全有记录
3. **零依赖**：不需要网络、不需要账号、不需要任何工具，一个文本文件就够

### tasks.md 长什么样？

```markdown
# 飞书通知渠道 - 任务清单

## Phase 1: 数据层
- [x] 在 channel_type enum 中加 'feishu' ✅ 2026-02-10
- [x] 创建 migration：alter channel_type ✅ 2026-02-10
- [x] 验收：`alembic upgrade head` 不报错 ✅ 2026-02-10

## Phase 2: 服务层
- [x] 创建 src/channels/feishu.py（参考 slack.py） ✅ 2026-02-11
- [ ] 实现 send_notification() 方法（调飞书 Webhook）
- [ ] 在 channel_factory.py 注册 feishu 渠道
- [ ] 验收：单元测试 mock 飞书 API 通过

## Phase 3: API 层
- [ ] 在 POST /api/notify 的 channel 参数中支持 feishu
- [ ] 验收：curl 发一条飞书通知，实际收到
```

看到没？`[ ]` 和 `[x]`——未做和已做，一目了然。

**关键不是格式，是工作方式**：每完成一项，你就把 `[ ]` 改成 `[x]`，然后 `git commit`。这个 commit 就是你的"进度快照"。

### 随时中止、随时恢复

这是 tasks.md 最被低估的价值。

你在做 Phase 2 的第二个任务，突然来了个紧急 bug 要修。你放下手头的活去修 bug。

修完 bug 回来——如果你靠的是 AI 对话上下文，完蛋了，对话早就断了。你得重新跟 AI 解释一遍"我们在做什么、做到哪了、接下来该做什么"。

但如果你有 tasks.md：

```text
请读 tasks.md，告诉我当前进度，继续下一个未完成的任务。
```

一句话，AI 就知道从哪里接着干。**因为上下文不在对话里，在文件里。**

这也意味着你可以随时换模型：Claude 做了前两个 Phase，GPT 来做第三个，Gemini 来做第四个——都不影响，因为它们读的是同一份 tasks.md。

### 怎么让 AI 生成 tasks.md？

```text
我要实现【功能描述】。

请先不要写代码，帮我生成 tasks.md：
1) 把功能拆成 3-5 个阶段（Phase），每个阶段独立可验收
2) 每个阶段列出具体任务（文件级别）
3) 每个阶段给验收标准（我怎么知道做对了）
4) 用 [ ] checkbox 格式

约束：
- 每个 Phase 改动不超过 5 个文件
- 不要重构现有代码，只做增量
- 不确定的地方标注 [待确认]
```

---

## 第二步：生成任务清单的同时出具设计文档

tasks.md 解决"做什么"，但还有一个更重要的问题："为什么这么做"。

**任务清单和设计文档必须同时出，互相关联。**

### 为什么？

因为 AI 做着做着会"忘记"设计意图。你让它做第三个 Phase 的时候，它可能已经不记得为什么 Phase 1 要这么设计了——然后它就按自己的理解"优化"一下，把你的架构搞乱。

有了设计文档，你就有了"设计意图的锚点"：

```text
请读 design.md 和 tasks.md，继续下一个任务。
注意遵循 design.md 中的架构约束。
```

### 设计文档写什么？

不需要很长，但必须写清楚 3 件事：

```markdown
# 飞书通知渠道 - 设计文档

## 设计决策

### 1. 用飞书 Webhook v2，不用 Bot API
- 原因：Webhook 不需要审批，Bot API 需要企业管理员授权
- 约束：Webhook 只能单向推送，不能接收回复
- 如果将来需要双向通信，再升级到 Bot API

### 2. 渠道实现统一用 Strategy 模式
- 参考：现有的 slack.py 实现
- 所有渠道实现 ChannelBase 接口
- channel_factory.py 统一注册和分发
- **不要引入新的设计模式**（这条很重要，防止 AI 自作主张）

### 3. 重试策略
- 最多重试 3 次
- 指数退避：1s → 2s → 4s
- 全部失败后记录到 failed_messages 表
- **不要用消息队列**（当前量级不需要，过度设计）

## 文件结构
```text
src/channels/
  base.py          # 渠道基类（已有）
  slack.py         # Slack 实现（已有，参考它）
  feishu.py        # 飞书实现（新增）
  factory.py       # 渠道工厂（修改：注册 feishu）
```

## 不做的事情（明确排除）
- 不做飞书消息卡片（只发纯文本）
- 不做 @人 功能
- 不做消息回执
```

注意最后那段"不做的事情"——这是给 AI 画红线。AI 最爱"顺手加功能"，你不明确说不做，它就给你做了。

### 提问模板：同时生成 tasks.md 和 design.md

```text
我要在 Orion 项目上加飞书通知渠道。

请同时输出两个文件：

1) design.md：
   - 设计决策（每个决策说原因 + 约束 + 不做的事情）
   - 文件结构
   - 接口定义

2) tasks.md：
   - 按 Phase 拆分，每个 Phase 关联 design.md 中的哪个决策
   - 每项任务标注影响的文件
   - 每个 Phase 给验收标准

两个文件要能互相引用：tasks.md 里说"参见 design.md 决策 2"，design.md 里说"由 Phase 2 实现"。
```

---

## 第三步：按清单推进，一步一 commit

有了 tasks.md 和 design.md，接下来就是执行。

### 工作节奏

```
读 tasks.md → 找到下一个 [ ] → 让 AI 执行 → 验收 → 更新 tasks.md → git commit → 下一个
```

**每完成一个任务就 commit**——这是"原子化提交"。好处：

1. **出事能精确回滚**：不是回滚整个功能，是回滚某一步
2. **进度可追踪**：`git log --oneline` 一看就知道做了什么
3. **换模型无缝衔接**：commit 之后，不管你换什么模型、开什么新对话，进度不丢

### 实战：fh_java 项目加 API 限流

```bash
# 开始之前
cat tasks.md
# Phase 1: 数据层 - 全部 [x]
# Phase 2: 限流中间件 - 第一个 [ ]

# 让 AI 执行
# "请读 tasks.md 和 design.md，执行 Phase 2 的第一个任务"

# AI 完成后，验收
mvn test -pl rate-limiter
# ✅ 通过

# 更新 tasks.md
# Phase 2 第一个任务 [ ] → [x] ✅ 2026-02-15

# 原子化提交
git add src/middleware/RateLimiter.java tasks.md
git commit -m "feat(rate-limiter): 实现令牌桶限流中间件"

# 下一个任务
# "请读 tasks.md，继续下一个未完成的任务"
```

### 关键提示：每次对话都从 tasks.md 开始

不管你是新开对话、换模型、还是第二天接着干，第一句话永远是：

```text
请读 tasks.md 和 design.md。
告诉我当前进度，然后继续下一个未完成的任务。
```

这就是"不相信任何模型的上下文"的实践——你不依赖 AI 记住任何东西，所有状态都在文件里。

---

## 常见翻车场景 & 对策

### 翻车 1：AI 出的计划粒度太粗

**症状**：tasks.md 里一项就是"实现用户管理"，没有文件级别的拆解

**对策**：
```text
这个计划粒度太粗。请把每项任务拆到"文件级别"：
- 具体创建/修改哪个文件
- 这个文件大概多少行改动
- 改完后怎么验证
```

### 翻车 2：AI 不按计划来，偷偷加私活

**症状**：你让它做 Phase 2，它顺手把 Phase 3 和 Phase 4 也做了

**对策**：
```text
严格只做 tasks.md 中 Phase 2 的内容。
不要修改 Phase 2 以外的任何文件。
如果发现需要额外改动，列出来但不要执行，等我确认。
```

### 翻车 3：计划和实际对不上

**症状**：做着做着发现计划里没考虑到某些依赖

**对策**：这是正常的。让 AI 更新 tasks.md 和 design.md：
```text
Phase 2 执行过程中发现需要额外处理 XXX。
请更新 tasks.md：在 Phase 2 里加上这个任务。
请更新 design.md：补充对应的设计决策。
然后 commit 这两个文件的变更。
```

### 翻车 4：AI 偏离设计文档

**症状**：design.md 说用 Strategy 模式，AI 突然搞了个 Observer 模式

**对策**：
```text
你的实现偏离了 design.md 中的决策 2（Strategy 模式）。
请严格按照 design.md 的架构实现。
如果你认为设计文档需要修改，先提出修改建议，等我确认后再改。
```

---

## 三种规划粒度，按项目大小选

### 小项目（1-3 天）：一个 tasks.md + 一个 design.md

```text
tasks.md      # 3-5 个 Phase
design.md     # 关键决策
```

### 中型项目（1-2 周）：按模块拆

```text
tasks/
  01-database.md
  02-backend-api.md
  03-frontend.md
  04-deployment.md
design/
  architecture.md   # 整体架构
  api-spec.md       # 接口定义
  data-model.md     # 数据模型
```

### 大项目（1 个月+）：按里程碑拆

```text
milestones/
  v0.1-mvp/
    tasks.md
    design.md
  v0.2-auth/
    tasks.md
    design.md
```

---

## 看到成果时……惊为天人

说了这么多"规矩"，你可能觉得太重了。但我想分享一个真实感受。

在做 fh_java 的时候，我第一次认真按照 tasks.md + design.md 的方式推进。前面的过程确实比"直接让 AI 写"要慢——要出计划、要出设计文档、要一步一验收、要原子化提交。

但当整个功能做完的那一刻，我打开项目一看：

- 每个文件都在它该在的位置
- 代码风格跟项目原有的完全一致
- Git log 清清楚楚，每一步都有据可查
- 测试全绿，冒烟测试一把过
- design.md 里的每个决策都有对应的实现

那一刻的感觉是——**惊为天人**。

不是 AI 写不出好代码。是你不给它约束，它就随便写。你给它清晰的框架、明确的边界、分步的清单——它的产出质量远超放任自由发挥。

**约束产生质量，自由产生混乱。** 这就是"规"的精髓。

---

## 和"喂"的配合：喂完再规

"喂"是给 AI 确定性（资料、文档、截图），"规"是给 AI 边界（计划、清单、约束）。

最佳实践：
1. 先"喂"：把相关的 API 文档、设计稿、技术方案喂到 `docs/_feed/`
2. 再"规"：基于喂进去的资料，让 AI 出 tasks.md + design.md
3. 然后执行：按 tasks.md 逐步推进，每步参照 design.md 的约束

这样 AI 既有"知识底座"（喂），又有"行动框架"（规），产出质量会质变。

---

## 总结

"规"的核心就三句话：

1. **不要相信任何模型的上下文** —— 把真相写在 tasks.md 和 design.md 里
2. **任务清单和设计文档同时出** —— tasks.md 管"做什么"，design.md 管"为什么"
3. **一步一验收，一步一 commit** —— 原子化推进，随时中止，随时恢复

**约束产生质量，自由产生混乱。**

下一式我们讲 **验**：AI 写的代码看起来对，但真的对吗？用多模型交叉验证，专治幻觉。
