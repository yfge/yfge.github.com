---
layout: post
title: vibe‑coding 九阳神功之规：别让 AI 自由发挥，给它 tasks.md 按清单推进
permalink: /jy/gui/
tags: [AI, vibe-coding, 九阳神功]
---
# vibe‑coding 九阳神功之**规**：别让 AI 自由发挥，给它 tasks.md 按清单推进

> 系列顺序：[夯（Git）](/jy/git/) → [抄](/jy/chao/) → [学](/jy/xue/) → [喂](/jy/wei/) → **规** → [验](/jy/yan/) → [测](/jy/ce/) → [扩](/jy/kuo/) → [收](/jy/shou/)
> 一句话：**AI 不是不能干活，是你没给它拉清单。没有计划的 AI 编程，就是在赌运气。**

AI 编程现在最大的坑不是"不会写"，而是：

- 写得太快
- 改得太多
- 炸了没后路
- 炸完你甚至不知道它到底改了哪些文件

所以我准备写一套 **vibe‑coding 九阳神功**：核心不是提示词，而是把 AI 变成"可控交付的队友"。

这套"九阳神功"我先定了九个字诀：

- **夯**：Git 生存技能（刹车 / 保险 / 录像）
- **抄**：拆解 `yfge/orion`、`ai-shifu/ai-shifu` 的优秀骨架，搭底盘
- **学**：学习行业黑话，会组合技术栈、不懂原理也能不翻车
- **喂**：把 API 文档 / 资料结构化成可执行知识
- **规**：让 AI 出计划 + `tasks.md`，按清单推进
- **验**：多模型交叉验证，专治幻觉
- **测**：自动测试，交付有证据
- **扩**：扩展认知边界，但必须可验证
- **收**：上线交付、监控回滚、复盘闭环

这篇咱们讲第五式 **规**：**让 AI 先出计划，再按清单一步一步推进，杜绝"一口气改 20 个文件然后全炸"。**

---

## 为什么必须"规"？

你一定遇到过这种场景：

> 你跟 AI 说"帮我加一个用户管理功能"，它二话不说改了 15 个文件，加了 3 张表，换了认证方案，顺手把你的路由全重构了。

然后你 `git diff` 一看——800 行改动，根本不知道哪些该留哪些该删。

**问题出在哪？** 不是 AI 不行，是你没给它约束。

AI 的默认行为是"给最完整的方案"。但你要的不是"最完整"，你要的是"可控地一步步交付"。

**"规"的核心**：在 AI 动手之前，先让它出计划。计划确认了，再一步一步执行。

---

## tasks.md：你的"施工清单"

我在做 Orion 和 ai-shifu 项目时，总结出一个最简单有效的方法：**用 `tasks.md` 管理 AI 的产出**。

### tasks.md 长什么样？

```markdown
# 用户管理功能 - 任务清单

## Phase 1: 数据层
- [ ] 创建 users 表 migration（字段：id, email, password_hash, created_at）
- [ ] 创建 User model（SQLAlchemy / Prisma / 随你选）
- [ ] 验收：migration 能跑通，表结构正确

## Phase 2: API 层
- [ ] POST /api/register（注册）
- [ ] POST /api/login（登录，返回 JWT）
- [ ] GET /api/me（获取当前用户信息）
- [ ] 验收：3 条 curl 能跑通

## Phase 3: 前端
- [ ] 登录页面（/login）
- [ ] 注册页面（/register）
- [ ] 用户信息页面（/profile）
- [ ] 验收：能走通注册→登录→看信息的完整流程

## Phase 4: 收尾
- [ ] 错误处理（重复注册、密码错误、token 过期）
- [ ] 环境变量配置（JWT_SECRET 等）
- [ ] 验收：异常场景不白屏
```

### 为什么这个格式好用？

1. **每个 Phase 独立可验收**：做完一个阶段就能验证，不用等全做完
2. **checkbox 天然是进度追踪**：做完一项打个勾，一目了然
3. **AI 能直接读**：下次对话直接说"继续做 tasks.md 里的 Phase 2"
4. **Git 友好**：每个 Phase 一个 commit，出事可以精确回滚

---

## 怎么让 AI 出计划？（提问模板）

### 模板 1：从需求到 tasks.md

```text
我要实现【功能描述】。

请先不要写代码，帮我：
1) 把功能拆成 3-5 个阶段（Phase），每个阶段独立可验收
2) 每个阶段列出具体任务（文件级别）
3) 每个阶段给验收标准（我怎么知道做对了）
4) 输出为 tasks.md 格式（用 checkbox）

约束：
- 每个 Phase 改动不超过 5 个文件
- 不要重构现有代码，只做增量
- 不确定的地方标注 [待确认]
```

### 模板 2：基于现有代码出计划

```text
@codebase

我要在现有项目上加【功能描述】。

请先分析现有代码结构，然后：
1) 列出需要新增和修改的文件清单
2) 按依赖关系排出执行顺序
3) 每步给验收标准
4) 输出为 tasks.md

约束：
- 不改变现有接口签名
- 不引入新的依赖（除非必须，需标注理由）
- 遵循项目现有的代码风格
```

---

## 实战案例：Orion 项目加通知渠道

我在给 Orion（通知网关）加飞书通知渠道时，就是用这套方法。

**需求**：支持飞书 Webhook 推送通知

**我的提问**：
```text
Orion 现在支持邮件和 Slack 通知。我要加飞书通知渠道。

请先出 tasks.md，不要直接写代码。要求：
1) 参考现有 Slack 通知的实现方式
2) 按数据层→服务层→API层→配置层拆分
3) 每步不超过 3 个文件改动
```

**AI 输出的 tasks.md**：

```markdown
# 飞书通知渠道 - 任务清单

## Phase 1: 数据层
- [ ] 在 channel_type enum 中加 'feishu'
- [ ] 创建 migration：alter channel_type
- [ ] 验收：`alembic upgrade head` 不报错

## Phase 2: 服务层
- [ ] 创建 src/channels/feishu.py（参考 slack.py）
- [ ] 实现 send_notification() 方法（调飞书 Webhook）
- [ ] 在 channel_factory.py 注册 feishu 渠道
- [ ] 验收：单元测试 mock 飞书 API 通过

## Phase 3: API 层
- [ ] 在 POST /api/notify 的 channel 参数中支持 feishu
- [ ] 验收：curl 发一条飞书通知，实际收到

## Phase 4: 配置与文档
- [ ] .env.example 加 FEISHU_WEBHOOK_URL
- [ ] README 更新：加飞书配置说明
- [ ] 验收：新人按文档能配通
```

**然后我一个 Phase 一个 Phase 地让 AI 执行**：

```text
请执行 tasks.md 的 Phase 1，完成后告诉我验收步骤。
```

做完 Phase 1，验收通过，`git commit`。再做 Phase 2……

**这比一口气让 AI 全写完要安全 10 倍。**

---

## 进阶：让 AI 自己维护 tasks.md

你可以在每次对话开头加一句：

```text
请先读 tasks.md，告诉我当前进度，然后继续下一个未完成的任务。
完成后更新 tasks.md（把完成的打勾，加上完成时间）。
```

这样 AI 就变成了一个"会看看板的员工"——它知道做到哪了，该做什么，做完会更新状态。

### 更进一步：在 tasks.md 里记录决策

```markdown
## Phase 2: 服务层
- [x] 创建 src/channels/feishu.py（参考 slack.py） ✅ 2026-02-10
  - 决策：用飞书 v2 webhook（不用 bot API，更简单）
  - 文件：src/channels/feishu.py（新增 45 行）
- [ ] 实现 send_notification() 方法
```

这样你回头看 tasks.md，不光知道做了什么，还知道**为什么这么做**。

---

## 三种规划粒度，按项目大小选

### 小项目（1-3 天）：一个 tasks.md 搞定

```text
tasks.md      # 一个文件，3-5 个 Phase
```

### 中型项目（1-2 周）：按模块拆

```text
tasks/
  01-database.md
  02-backend-api.md
  03-frontend.md
  04-deployment.md
```

### 大项目（1 个月+）：按里程碑拆

```text
milestones/
  v0.1-mvp/
    tasks.md
    decisions.md     # 关键技术决策记录
  v0.2-auth/
    tasks.md
    decisions.md
```

---

## 常见翻车场景 & 对策

### 翻车 1：AI 出的计划粒度太粗

**症状**：tasks.md 里一项就是"实现用户管理"，没有文件级别的拆解

**对策**：
```text
这个计划粒度太粗。请把每项任务拆到"文件级别"：
- 具体创建/修改哪个文件
- 这个文件大概多少行改动
- 改完后怎么验证
```

### 翻车 2：AI 不按计划来，偷偷加私活

**症状**：你让它做 Phase 2，它顺手把 Phase 3 和 Phase 4 也做了

**对策**：
```text
严格只做 tasks.md 中 Phase 2 的内容。
不要修改 Phase 2 以外的任何文件。
如果发现需要额外改动，列出来但不要执行，等我确认。
```

### 翻车 3：计划和实际对不上

**症状**：做着做着发现计划里没考虑到某些依赖

**对策**：这是正常的。让 AI 更新 tasks.md：
```text
Phase 2 执行过程中发现需要额外处理 XXX。
请更新 tasks.md：在 Phase 2 里加上这个任务，并评估是否影响后续 Phase。
```

---

## 黄金法则：先规划，再执行，一步一验收

整个"规"的工作流：

```
需求 → 让 AI 出 tasks.md → 确认计划 → 逐 Phase 执行 → 每 Phase 验收 + commit → 完成
```

**记住这 3 条铁律**：

1. **AI 动手之前，必须先出计划** —— 不看到 tasks.md 不让它写代码
2. **每个 Phase 不超过 5 个文件** —— 改太多你审不过来
3. **每个 Phase 必须有验收标准** —— "做完了"不算完，"验收通过了"才算完

---

## 和"喂"的配合：喂完再规

"喂"是给 AI 确定性（资料、文档、截图），"规"是给 AI 边界（计划、清单、约束）。

最佳实践：
1. 先"喂"：把相关的 API 文档、设计稿、技术方案喂到 `docs/_feed/`
2. 再"规"：基于喂进去的资料，让 AI 出 tasks.md
3. 然后执行：按 tasks.md 逐步推进

这样 AI 既有"知识底座"（喂），又有"行动框架"（规），产出质量会质变。

---

## 总结

"规"的核心就一句话：**不让 AI 自由发挥，给它框架和约束。**

- 没有计划的 AI 编程 = 赌运气
- 有 tasks.md 的 AI 编程 = 可控交付
- 每个 Phase 一个 commit = 出事能回滚
- 验收标准写清楚 = "做完"有定义

下一式我们讲 **验**：AI 写的代码看起来对，但真的对吗？用多模型交叉验证，专治幻觉。
