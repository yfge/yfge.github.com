---
layout: post
title: 用 AI 写了好几个项目上线的人，聊聊我为什么支持 Vibe Coding
date: 2026-02-28
tags: [AI, vibe-coding, 编程]
---

支持。而且我认为争论"是否支持"这件事本身已经没意义了。

我写了十几年代码，去年开始用 AI（Claude Code + Codex）做项目，到今天为止上线了好几个——开源通知网关 Orion、agentskill.work 目录站、ZhiForge 自动化工具链，还有一堆小工具。这些项目里，AI 写了绝大多数代码，我写了规范文件和架构判断。

所以我不是在讨论一个概念，我是在说一种我每天都在用的工作方式。

---

先说个具体的事。

agentskill.work 这个站，从想法到上线，半天。

AI 帮我写了全部代码：前端 Next.js 页面、后端 FastAPI 接口、GitHub API 数据抓取、Celery 定时任务、Nginx 反代配置、Let's Encrypt 证书自动化、Docker Compose 编排、Umami 埋点统计。

全部。一行没手写。

但这里面有个东西很多人忽略了：**每个技术决策是我做的。**

用 Celery 而不是 cron——因为我之前被 cron 坑过，定时任务失败了没日志没重试没告警，排查问题的时候恨不得砸键盘。Celery 自带重试、自带记录、队列就是系统心跳，出问题能定位。

限流是我逼着 AI 加的。GitHub API rate limit 一打满，你站就白了。AI 写代码的时候压根不会想这个——它甚至会在前端直接请求 GitHub API，你不说它觉得这很合理。

证书自动续期我也盯着配了。Let's Encrypt 90 天过期，这事我之前在另一个项目上忘了，上线三个月突然 HTTPS 红锁了，客户打电话过来的时候我整个人是懵的。

AI 写了 100% 的代码，但架构判断力占了这个项目 80% 的价值。

---

顺便说一下效果：上线三天，Google Search Console 就出现了收录信号。详情页开始有长尾词展示和点击。这不是因为我懂 SEO——我一窍不通——是因为我让 AI 按规矩做了 `robots.txt`、sitemap、JSON-LD 结构化数据、还有 `llms.txt` 面向 LLM 的索引文件。我不懂 SEO，但我知道"不懂就查、查完就做、做完就验证"。AI 是电钻，不是建筑师。

---

再说个更小的事，但特别说明问题。

有天我想把博客文章发到 X.com 的编辑器里，保留 Markdown 格式。听着挺简单对吧？

我跟 Claude 说了需求，它先给我输出纯文本——粘贴过去格式全丢。我说要富文本。它用 `pbcopy` 复制——还是纯文本，因为 `pbcopy` 只能复制纯文本。我说要用 `NSPasteboard` 设置 HTML 格式。它给我建虚拟环境装 `pyobjc-framework-Cocoa`——终于有格式了，但代码块没了。我说 X.com 不支持代码块。它给我转引用块——好了，但表格没了。我说也不支持表格。它给我转列表——终于能用了。

来来回回改了五六轮，40 分钟。

这就是 vibe coding 的真实状态：**AI 像一个手速极快但缺乏常识的初级工程师。** 你告诉它该怎么做，它秒给你写出来。你不告诉它，它就一路走到黑。

说白了，它不会主动说"你这个思路走不通"。它只会顺着你的指令往下写，直到你发现不对。

---

Orion 项目更大，坑也更深。

后端 FastAPI + SQLAlchemy，前端 Next.js + Tailwind，Docker Compose 一键拉起。几乎所有代码都是 AI 生成的。

项目大了以后 AI 就开始"忘事"——改了 A 文件忘了 B 文件也要同步改，写了新接口忘了更新文档，加了数据库字段忘了写 migration 脚本。有一次它把我的路由表改乱了，前端调后端全 404，我排查了快一个小时才发现它把路由前缀悄悄改了一个字母。

后来我写了个 AGENTS.md，相当于项目的"宪法"。所有 AI（Claude、Gemini、Cursor 的规则文件）都指向它。里面写死了目录结构、提交规范、分支策略。CI 强制检查：改核心代码必须带配套文档（`agents_chat/` 目录下的协作记录），少一个不让合。

我还要求每次 AI 动手之前必须先 `git diff`，改完之后先 `git status` 看改了哪些文件，确认没越界再提交。大改之前开分支，崩了就删分支回主线，心态干净。

这套东西听着像形式主义，其实是活命线。没有它，AI 写的东西你根本不敢上线。

---

我后来专门统计了一下 Orion 项目的 agents_chat 目录：三周开发期间攒了 47 条协作记录。平均每条包含需求、做了什么、验收命令、TODO。这些记录不是为了好看，是真的有人（包括我自己）后来回去翻，搞清楚"两周前那个接口为什么这么设计"。

这种"过程可审计"的开发方式，我觉得比代码本身更有价值。传统的开源项目开源的是代码，vibe coding 时代应该开源的是开发过程——需求怎么提的、AI 怎么理解的、为什么改了三遍、最终为什么选了这个方案。

---

说回"是否支持 vibe coding"这个问题。

我觉得争论这个，跟十年前争论"是否支持用 Stack Overflow 查代码"一样，属于浪费时间。

工具就是工具。关键看你用它做什么、怎么用。

我见过有人用 AI 写出一堆能跑的 demo，然后上线就炸，因为没限流没缓存没错误处理。这不是 AI 的问题，是用的人没有工程判断力。

我也见过有人一行 AI 代码都不敢用，非要手搓，结果同样的活别人半天搞定他搞了两周。这也不是什么工匠精神，就是固执。

vibe coding 真正改变的是什么？

**软件的"写出来"部分变得廉价了。** 以前写一个功能可能要一天，现在可能半小时。以前学一个新框架要一周上手，现在跟 AI 说"用 XXX 框架帮我搭个 YYY"，十分钟出来一个能跑的骨架。

但"做对"变得更贵了。

限流要不要加？缓存策略怎么选？定时任务用什么方案？数据库 migration 谁来管？证书过期了怎么办？部署链路会不会在某个节点卡死？

这些问题 AI 不会替你考虑。它写代码的时候不会想"三个月后证书过期了怎么办"。它也不会想"GitHub API rate limit 打满了你的站会变成白屏"。

这些判断力从哪来？踩坑。

我那些"每次让 AI 动手前先 git commit"的习惯，是被 AI 改乱代码之后养成的。我那些"限流必须有、缓存必须有、失败必须降级"的要求，是被线上事故教出来的。

这些经验，恰好是 vibe coding 时代最值钱的东西。

---

所以我的观点很明确：

Vibe coding 不值得争论。它已经是事实了。就像 Dario Amodei 说的：It's the only coding game in town.

该争论的是：在 AI 帮你写了 100% 代码的情况下，你那"0% 的代码"里到底藏着多少判断力？

你写的 AGENTS.md 值不值钱？你设计的 CI 流程值不值钱？你盯着的那些"AI 不会想到但迟早会炸"的细节值不值钱？

如果你只是让 AI 写个 demo，跑通就完事——那你确实不需要 vibe coding，因为你本来就不需要编程。

如果你想把东西做到能上线、能长期跑、能扛住现实——那 vibe coding 是你效率翻倍的入口，而你的工程判断力是你在这个时代不被替代的护城河。

我再说一遍那句话：**AI 是施工队，你是总工 + 质检员。**

施工队越能干，总工越值钱。

反过来说，如果你觉得自己被施工队替代了，那可能你一直干的就是施工队的活。

---

对了，我之前有个认知是错的，说出来可能有些人会不服。

我以前觉得"代码要复用，所以要写得通用"。这是软件工程教了我们二十年的东西。

但去年开始我发现：很多时候"现场造一个"比"找一个通用的"更快。

那个 X.com 发文工具就是例子。GitHub 上有现成项目，我没 clone。不是它不好，是"描述需求让 AI 写"比"找到项目、理解结构、配环境、跑起来"更短。而且 AI 写出来的东西完全贴合我的项目结构——它知道我的 `_posts` 在哪、文章格式是什么、系统是 macOS。这不是通用工具，这是现场定制，用完即走。

软件的"写"变廉价之后，"复用"的性价比在下降，"定制"的性价比在上升。

这个转变对程序员意味着什么？意味着"能快速理解需求并做出正确的技术判断"比"能写出优雅的可复用代码"更值钱。

以前值钱的是手速。现在值钱的是脑子。

我知道这话说出来有点得罪人，但这就是我过去一年实际做项目的真实体感。你可以不同意，但建议先用 AI 真正做一个上线的项目再下结论。光写 demo 不算。
